schema {
  query: Query
  subscription: Subscription
}

"Marks the GraphQL type as indexable entity.  Each type that should be an entity is required to be annotated with this directive."
directive @entity on OBJECT

"Defined a Subgraph ID for an object type"
directive @subgraphId(id: String!) on OBJECT

"creates a virtual field on the entity that may be queried but cannot be set manually through the mappings API."
directive @derivedFrom(field: String!) on FIELD_DEFINITION

scalar BILLING__BigDecimal

scalar BigInt

"""
Billing holds global variables

"""
type BILLING__Billing {
  """Set to 1"""
  id: ID!
  """Address of the gateway"""
  gateway: BILLING__Bytes!
  """Address of the governor"""
  governor: BILLING__Bytes!
  """[CUMULATIVE] Total amount of tokens added"""
  totalTokensAdded: BigInt!
  """[CUMULATIVE] Total amount of tokens pulled"""
  totalTokensPulled: BigInt!
  """[CUMULATIVE] Total amount of tokens removed/withdrawn"""
  totalTokensRemoved: BigInt!
  """
  [CURRENT] Total amount of currently available balance (totalTokensAdded - totalTokensPulled - totalTokensRemoved)
  """
  totalCurrentBalance: BigInt!
  """Current BillingDailyData entity created"""
  currentDailyDataEntity: BILLING__BillingDailyData
  """Previous BillingDailyData entity created"""
  previousDailyDataEntity: BILLING__BillingDailyData
}

type BILLING__BillingDailyData {
  """<SUBGRAPH ID>-<DAY NUMBER>"""
  id: ID!
  """Timestamp for the start of the day that this entity represents. UTC+0"""
  dayStart: BigInt!
  """Timestamp for the end of the day that this entity represents. UTC+0"""
  dayEnd: BigInt!
  """
  Number of the day this entity represents. Day 0 is the network launch day.
  """
  dayNumber: Int!
  """Original entity that the daily data entity tracks"""
  entity: BILLING__Billing!
  """[CUMULATIVE] Total amount of tokens added"""
  totalTokensAdded: BigInt!
  """[CUMULATIVE] Total amount of tokens pulled"""
  totalTokensPulled: BigInt!
  """[CUMULATIVE] Total amount of tokens removed/withdrawn"""
  totalTokensRemoved: BigInt!
  """
  [CURRENT] Total amount of currently available balance (totalTokensAdded - totalTokensPulled - totalTokensRemoved)
  """
  totalCurrentBalance: BigInt!
  """Address of the gateway"""
  gateway: BILLING__Bytes!
  """Address of the governor"""
  governor: BILLING__Bytes!
  """[DELTA] Chage in total tokens added since the last DailyData point"""
  totalTokensAddedDelta: BigInt!
  """[DELTA] Chage in total tokens pulled since the last DailyData point"""
  totalTokensPulledDelta: BigInt!
  """
  [DELTA] Chage in total tokens removed/withdrawn since the last DailyData point
  """
  totalTokensRemovedDelta: BigInt!
  """
  [DELTA] Chage in total currently available balance since the last DailyData point
  """
  totalCurrentBalanceDelta: BigInt!
}

input BILLING__BillingDailyData_filter {
  id: ID
  id_not: ID
  id_gt: ID
  id_lt: ID
  id_gte: ID
  id_lte: ID
  id_in: [ID!]
  id_not_in: [ID!]
  dayStart: BigInt
  dayStart_not: BigInt
  dayStart_gt: BigInt
  dayStart_lt: BigInt
  dayStart_gte: BigInt
  dayStart_lte: BigInt
  dayStart_in: [BigInt!]
  dayStart_not_in: [BigInt!]
  dayEnd: BigInt
  dayEnd_not: BigInt
  dayEnd_gt: BigInt
  dayEnd_lt: BigInt
  dayEnd_gte: BigInt
  dayEnd_lte: BigInt
  dayEnd_in: [BigInt!]
  dayEnd_not_in: [BigInt!]
  dayNumber: Int
  dayNumber_not: Int
  dayNumber_gt: Int
  dayNumber_lt: Int
  dayNumber_gte: Int
  dayNumber_lte: Int
  dayNumber_in: [Int!]
  dayNumber_not_in: [Int!]
  entity: String
  entity_not: String
  entity_gt: String
  entity_lt: String
  entity_gte: String
  entity_lte: String
  entity_in: [String!]
  entity_not_in: [String!]
  entity_contains: String
  entity_contains_nocase: String
  entity_not_contains: String
  entity_not_contains_nocase: String
  entity_starts_with: String
  entity_starts_with_nocase: String
  entity_not_starts_with: String
  entity_not_starts_with_nocase: String
  entity_ends_with: String
  entity_ends_with_nocase: String
  entity_not_ends_with: String
  entity_not_ends_with_nocase: String
  entity_: BILLING__Billing_filter
  totalTokensAdded: BigInt
  totalTokensAdded_not: BigInt
  totalTokensAdded_gt: BigInt
  totalTokensAdded_lt: BigInt
  totalTokensAdded_gte: BigInt
  totalTokensAdded_lte: BigInt
  totalTokensAdded_in: [BigInt!]
  totalTokensAdded_not_in: [BigInt!]
  totalTokensPulled: BigInt
  totalTokensPulled_not: BigInt
  totalTokensPulled_gt: BigInt
  totalTokensPulled_lt: BigInt
  totalTokensPulled_gte: BigInt
  totalTokensPulled_lte: BigInt
  totalTokensPulled_in: [BigInt!]
  totalTokensPulled_not_in: [BigInt!]
  totalTokensRemoved: BigInt
  totalTokensRemoved_not: BigInt
  totalTokensRemoved_gt: BigInt
  totalTokensRemoved_lt: BigInt
  totalTokensRemoved_gte: BigInt
  totalTokensRemoved_lte: BigInt
  totalTokensRemoved_in: [BigInt!]
  totalTokensRemoved_not_in: [BigInt!]
  totalCurrentBalance: BigInt
  totalCurrentBalance_not: BigInt
  totalCurrentBalance_gt: BigInt
  totalCurrentBalance_lt: BigInt
  totalCurrentBalance_gte: BigInt
  totalCurrentBalance_lte: BigInt
  totalCurrentBalance_in: [BigInt!]
  totalCurrentBalance_not_in: [BigInt!]
  gateway: BILLING__Bytes
  gateway_not: BILLING__Bytes
  gateway_gt: BILLING__Bytes
  gateway_lt: BILLING__Bytes
  gateway_gte: BILLING__Bytes
  gateway_lte: BILLING__Bytes
  gateway_in: [BILLING__Bytes!]
  gateway_not_in: [BILLING__Bytes!]
  gateway_contains: BILLING__Bytes
  gateway_not_contains: BILLING__Bytes
  governor: BILLING__Bytes
  governor_not: BILLING__Bytes
  governor_gt: BILLING__Bytes
  governor_lt: BILLING__Bytes
  governor_gte: BILLING__Bytes
  governor_lte: BILLING__Bytes
  governor_in: [BILLING__Bytes!]
  governor_not_in: [BILLING__Bytes!]
  governor_contains: BILLING__Bytes
  governor_not_contains: BILLING__Bytes
  totalTokensAddedDelta: BigInt
  totalTokensAddedDelta_not: BigInt
  totalTokensAddedDelta_gt: BigInt
  totalTokensAddedDelta_lt: BigInt
  totalTokensAddedDelta_gte: BigInt
  totalTokensAddedDelta_lte: BigInt
  totalTokensAddedDelta_in: [BigInt!]
  totalTokensAddedDelta_not_in: [BigInt!]
  totalTokensPulledDelta: BigInt
  totalTokensPulledDelta_not: BigInt
  totalTokensPulledDelta_gt: BigInt
  totalTokensPulledDelta_lt: BigInt
  totalTokensPulledDelta_gte: BigInt
  totalTokensPulledDelta_lte: BigInt
  totalTokensPulledDelta_in: [BigInt!]
  totalTokensPulledDelta_not_in: [BigInt!]
  totalTokensRemovedDelta: BigInt
  totalTokensRemovedDelta_not: BigInt
  totalTokensRemovedDelta_gt: BigInt
  totalTokensRemovedDelta_lt: BigInt
  totalTokensRemovedDelta_gte: BigInt
  totalTokensRemovedDelta_lte: BigInt
  totalTokensRemovedDelta_in: [BigInt!]
  totalTokensRemovedDelta_not_in: [BigInt!]
  totalCurrentBalanceDelta: BigInt
  totalCurrentBalanceDelta_not: BigInt
  totalCurrentBalanceDelta_gt: BigInt
  totalCurrentBalanceDelta_lt: BigInt
  totalCurrentBalanceDelta_gte: BigInt
  totalCurrentBalanceDelta_lte: BigInt
  totalCurrentBalanceDelta_in: [BigInt!]
  totalCurrentBalanceDelta_not_in: [BigInt!]
  """Filter for the block changed event."""
  _change_block: BILLING__BlockChangedFilter
}

enum BILLING__BillingDailyData_orderBy {
  id
  dayStart
  dayEnd
  dayNumber
  entity
  totalTokensAdded
  totalTokensPulled
  totalTokensRemoved
  totalCurrentBalance
  gateway
  governor
  totalTokensAddedDelta
  totalTokensPulledDelta
  totalTokensRemovedDelta
  totalCurrentBalanceDelta
}

input BILLING__Billing_filter {
  id: ID
  id_not: ID
  id_gt: ID
  id_lt: ID
  id_gte: ID
  id_lte: ID
  id_in: [ID!]
  id_not_in: [ID!]
  gateway: BILLING__Bytes
  gateway_not: BILLING__Bytes
  gateway_gt: BILLING__Bytes
  gateway_lt: BILLING__Bytes
  gateway_gte: BILLING__Bytes
  gateway_lte: BILLING__Bytes
  gateway_in: [BILLING__Bytes!]
  gateway_not_in: [BILLING__Bytes!]
  gateway_contains: BILLING__Bytes
  gateway_not_contains: BILLING__Bytes
  governor: BILLING__Bytes
  governor_not: BILLING__Bytes
  governor_gt: BILLING__Bytes
  governor_lt: BILLING__Bytes
  governor_gte: BILLING__Bytes
  governor_lte: BILLING__Bytes
  governor_in: [BILLING__Bytes!]
  governor_not_in: [BILLING__Bytes!]
  governor_contains: BILLING__Bytes
  governor_not_contains: BILLING__Bytes
  totalTokensAdded: BigInt
  totalTokensAdded_not: BigInt
  totalTokensAdded_gt: BigInt
  totalTokensAdded_lt: BigInt
  totalTokensAdded_gte: BigInt
  totalTokensAdded_lte: BigInt
  totalTokensAdded_in: [BigInt!]
  totalTokensAdded_not_in: [BigInt!]
  totalTokensPulled: BigInt
  totalTokensPulled_not: BigInt
  totalTokensPulled_gt: BigInt
  totalTokensPulled_lt: BigInt
  totalTokensPulled_gte: BigInt
  totalTokensPulled_lte: BigInt
  totalTokensPulled_in: [BigInt!]
  totalTokensPulled_not_in: [BigInt!]
  totalTokensRemoved: BigInt
  totalTokensRemoved_not: BigInt
  totalTokensRemoved_gt: BigInt
  totalTokensRemoved_lt: BigInt
  totalTokensRemoved_gte: BigInt
  totalTokensRemoved_lte: BigInt
  totalTokensRemoved_in: [BigInt!]
  totalTokensRemoved_not_in: [BigInt!]
  totalCurrentBalance: BigInt
  totalCurrentBalance_not: BigInt
  totalCurrentBalance_gt: BigInt
  totalCurrentBalance_lt: BigInt
  totalCurrentBalance_gte: BigInt
  totalCurrentBalance_lte: BigInt
  totalCurrentBalance_in: [BigInt!]
  totalCurrentBalance_not_in: [BigInt!]
  currentDailyDataEntity: String
  currentDailyDataEntity_not: String
  currentDailyDataEntity_gt: String
  currentDailyDataEntity_lt: String
  currentDailyDataEntity_gte: String
  currentDailyDataEntity_lte: String
  currentDailyDataEntity_in: [String!]
  currentDailyDataEntity_not_in: [String!]
  currentDailyDataEntity_contains: String
  currentDailyDataEntity_contains_nocase: String
  currentDailyDataEntity_not_contains: String
  currentDailyDataEntity_not_contains_nocase: String
  currentDailyDataEntity_starts_with: String
  currentDailyDataEntity_starts_with_nocase: String
  currentDailyDataEntity_not_starts_with: String
  currentDailyDataEntity_not_starts_with_nocase: String
  currentDailyDataEntity_ends_with: String
  currentDailyDataEntity_ends_with_nocase: String
  currentDailyDataEntity_not_ends_with: String
  currentDailyDataEntity_not_ends_with_nocase: String
  currentDailyDataEntity_: BILLING__BillingDailyData_filter
  previousDailyDataEntity: String
  previousDailyDataEntity_not: String
  previousDailyDataEntity_gt: String
  previousDailyDataEntity_lt: String
  previousDailyDataEntity_gte: String
  previousDailyDataEntity_lte: String
  previousDailyDataEntity_in: [String!]
  previousDailyDataEntity_not_in: [String!]
  previousDailyDataEntity_contains: String
  previousDailyDataEntity_contains_nocase: String
  previousDailyDataEntity_not_contains: String
  previousDailyDataEntity_not_contains_nocase: String
  previousDailyDataEntity_starts_with: String
  previousDailyDataEntity_starts_with_nocase: String
  previousDailyDataEntity_not_starts_with: String
  previousDailyDataEntity_not_starts_with_nocase: String
  previousDailyDataEntity_ends_with: String
  previousDailyDataEntity_ends_with_nocase: String
  previousDailyDataEntity_not_ends_with: String
  previousDailyDataEntity_not_ends_with_nocase: String
  previousDailyDataEntity_: BILLING__BillingDailyData_filter
  """Filter for the block changed event."""
  _change_block: BILLING__BlockChangedFilter
}

enum BILLING__Billing_orderBy {
  id
  gateway
  governor
  totalTokensAdded
  totalTokensPulled
  totalTokensRemoved
  totalCurrentBalance
  currentDailyDataEntity
  previousDailyDataEntity
}

input BILLING__BlockChangedFilter {
  number_gte: Int!
}

input BILLING__Block_height {
  hash: BILLING__Bytes
  number: Int
  number_gte: Int
}

scalar BILLING__Bytes

"""Defines the order direction, either ascending or descending"""
enum BILLING__OrderDirection {
  asc
  desc
}

type Query {
  BILLING__billing(
    id: ID!
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: BILLING__Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: BILLING___SubgraphErrorPolicy_! = deny
  ): BILLING__Billing
  BILLING__billings(
    skip: Int = 0
    first: Int = 100
    orderBy: BILLING__Billing_orderBy
    orderDirection: BILLING__OrderDirection
    where: BILLING__Billing_filter
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: BILLING__Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: BILLING___SubgraphErrorPolicy_! = deny
  ): [BILLING__Billing!]!
  BILLING__user(
    id: ID!
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: BILLING__Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: BILLING___SubgraphErrorPolicy_! = deny
  ): BILLING__User
  BILLING__users(
    skip: Int = 0
    first: Int = 100
    orderBy: BILLING__User_orderBy
    orderDirection: BILLING__OrderDirection
    where: BILLING__User_filter
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: BILLING__Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: BILLING___SubgraphErrorPolicy_! = deny
  ): [BILLING__User!]!
  BILLING__tokensAdded(
    id: ID!
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: BILLING__Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: BILLING___SubgraphErrorPolicy_! = deny
  ): BILLING__TokensAdded
  BILLING__tokensAddeds(
    skip: Int = 0
    first: Int = 100
    orderBy: BILLING__TokensAdded_orderBy
    orderDirection: BILLING__OrderDirection
    where: BILLING__TokensAdded_filter
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: BILLING__Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: BILLING___SubgraphErrorPolicy_! = deny
  ): [BILLING__TokensAdded!]!
  BILLING__tokensRemoved(
    id: ID!
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: BILLING__Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: BILLING___SubgraphErrorPolicy_! = deny
  ): BILLING__TokensRemoved
  BILLING__tokensRemoveds(
    skip: Int = 0
    first: Int = 100
    orderBy: BILLING__TokensRemoved_orderBy
    orderDirection: BILLING__OrderDirection
    where: BILLING__TokensRemoved_filter
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: BILLING__Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: BILLING___SubgraphErrorPolicy_! = deny
  ): [BILLING__TokensRemoved!]!
  BILLING__tokensPulled(
    id: ID!
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: BILLING__Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: BILLING___SubgraphErrorPolicy_! = deny
  ): BILLING__TokensPulled
  BILLING__tokensPulleds(
    skip: Int = 0
    first: Int = 100
    orderBy: BILLING__TokensPulled_orderBy
    orderDirection: BILLING__OrderDirection
    where: BILLING__TokensPulled_filter
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: BILLING__Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: BILLING___SubgraphErrorPolicy_! = deny
  ): [BILLING__TokensPulled!]!
  BILLING__billingDailyData(
    id: ID!
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: BILLING__Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: BILLING___SubgraphErrorPolicy_! = deny
  ): BILLING__BillingDailyData
  BILLING__billingDailyDatas(
    skip: Int = 0
    first: Int = 100
    orderBy: BILLING__BillingDailyData_orderBy
    orderDirection: BILLING__OrderDirection
    where: BILLING__BillingDailyData_filter
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: BILLING__Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: BILLING___SubgraphErrorPolicy_! = deny
  ): [BILLING__BillingDailyData!]!
  BILLING__userDailyData(
    id: ID!
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: BILLING__Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: BILLING___SubgraphErrorPolicy_! = deny
  ): BILLING__UserDailyData
  BILLING__userDailyDatas(
    skip: Int = 0
    first: Int = 100
    orderBy: BILLING__UserDailyData_orderBy
    orderDirection: BILLING__OrderDirection
    where: BILLING__UserDailyData_filter
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: BILLING__Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: BILLING___SubgraphErrorPolicy_! = deny
  ): [BILLING__UserDailyData!]!
  BILLING__transaction(
    id: ID!
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: BILLING__Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: BILLING___SubgraphErrorPolicy_! = deny
  ): BILLING__Transaction
  BILLING__transactions(
    skip: Int = 0
    first: Int = 100
    orderBy: BILLING__Transaction_orderBy
    orderDirection: BILLING__OrderDirection
    where: BILLING__Transaction_filter
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: BILLING__Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: BILLING___SubgraphErrorPolicy_! = deny
  ): [BILLING__Transaction!]!
  """Access to subgraph metadata"""
  BILLING___meta(block: BILLING__Block_height): BILLING___Meta_
}

type Subscription {
  BILLING__billing(
    id: ID!
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: BILLING__Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: BILLING___SubgraphErrorPolicy_! = deny
  ): BILLING__Billing
  BILLING__billings(
    skip: Int = 0
    first: Int = 100
    orderBy: BILLING__Billing_orderBy
    orderDirection: BILLING__OrderDirection
    where: BILLING__Billing_filter
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: BILLING__Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: BILLING___SubgraphErrorPolicy_! = deny
  ): [BILLING__Billing!]!
  BILLING__user(
    id: ID!
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: BILLING__Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: BILLING___SubgraphErrorPolicy_! = deny
  ): BILLING__User
  BILLING__users(
    skip: Int = 0
    first: Int = 100
    orderBy: BILLING__User_orderBy
    orderDirection: BILLING__OrderDirection
    where: BILLING__User_filter
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: BILLING__Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: BILLING___SubgraphErrorPolicy_! = deny
  ): [BILLING__User!]!
  BILLING__tokensAdded(
    id: ID!
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: BILLING__Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: BILLING___SubgraphErrorPolicy_! = deny
  ): BILLING__TokensAdded
  BILLING__tokensAddeds(
    skip: Int = 0
    first: Int = 100
    orderBy: BILLING__TokensAdded_orderBy
    orderDirection: BILLING__OrderDirection
    where: BILLING__TokensAdded_filter
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: BILLING__Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: BILLING___SubgraphErrorPolicy_! = deny
  ): [BILLING__TokensAdded!]!
  BILLING__tokensRemoved(
    id: ID!
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: BILLING__Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: BILLING___SubgraphErrorPolicy_! = deny
  ): BILLING__TokensRemoved
  BILLING__tokensRemoveds(
    skip: Int = 0
    first: Int = 100
    orderBy: BILLING__TokensRemoved_orderBy
    orderDirection: BILLING__OrderDirection
    where: BILLING__TokensRemoved_filter
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: BILLING__Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: BILLING___SubgraphErrorPolicy_! = deny
  ): [BILLING__TokensRemoved!]!
  BILLING__tokensPulled(
    id: ID!
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: BILLING__Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: BILLING___SubgraphErrorPolicy_! = deny
  ): BILLING__TokensPulled
  BILLING__tokensPulleds(
    skip: Int = 0
    first: Int = 100
    orderBy: BILLING__TokensPulled_orderBy
    orderDirection: BILLING__OrderDirection
    where: BILLING__TokensPulled_filter
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: BILLING__Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: BILLING___SubgraphErrorPolicy_! = deny
  ): [BILLING__TokensPulled!]!
  BILLING__billingDailyData(
    id: ID!
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: BILLING__Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: BILLING___SubgraphErrorPolicy_! = deny
  ): BILLING__BillingDailyData
  BILLING__billingDailyDatas(
    skip: Int = 0
    first: Int = 100
    orderBy: BILLING__BillingDailyData_orderBy
    orderDirection: BILLING__OrderDirection
    where: BILLING__BillingDailyData_filter
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: BILLING__Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: BILLING___SubgraphErrorPolicy_! = deny
  ): [BILLING__BillingDailyData!]!
  BILLING__userDailyData(
    id: ID!
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: BILLING__Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: BILLING___SubgraphErrorPolicy_! = deny
  ): BILLING__UserDailyData
  BILLING__userDailyDatas(
    skip: Int = 0
    first: Int = 100
    orderBy: BILLING__UserDailyData_orderBy
    orderDirection: BILLING__OrderDirection
    where: BILLING__UserDailyData_filter
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: BILLING__Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: BILLING___SubgraphErrorPolicy_! = deny
  ): [BILLING__UserDailyData!]!
  BILLING__transaction(
    id: ID!
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: BILLING__Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: BILLING___SubgraphErrorPolicy_! = deny
  ): BILLING__Transaction
  BILLING__transactions(
    skip: Int = 0
    first: Int = 100
    orderBy: BILLING__Transaction_orderBy
    orderDirection: BILLING__OrderDirection
    where: BILLING__Transaction_filter
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: BILLING__Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: BILLING___SubgraphErrorPolicy_! = deny
  ): [BILLING__Transaction!]!
  """Access to subgraph metadata"""
  BILLING___meta(block: BILLING__Block_height): BILLING___Meta_
}

"""
TokensAdded Transaction

"""
type BILLING__TokensAdded implements BILLING__Transaction {
  id: ID!
  hash: BILLING__Bytes!
  blockNumber: Int!
  timestamp: Int!
  user: BILLING__User!
  amount: BigInt!
  type: BILLING__TransactionType!
}

input BILLING__TokensAdded_filter {
  id: ID
  id_not: ID
  id_gt: ID
  id_lt: ID
  id_gte: ID
  id_lte: ID
  id_in: [ID!]
  id_not_in: [ID!]
  hash: BILLING__Bytes
  hash_not: BILLING__Bytes
  hash_gt: BILLING__Bytes
  hash_lt: BILLING__Bytes
  hash_gte: BILLING__Bytes
  hash_lte: BILLING__Bytes
  hash_in: [BILLING__Bytes!]
  hash_not_in: [BILLING__Bytes!]
  hash_contains: BILLING__Bytes
  hash_not_contains: BILLING__Bytes
  blockNumber: Int
  blockNumber_not: Int
  blockNumber_gt: Int
  blockNumber_lt: Int
  blockNumber_gte: Int
  blockNumber_lte: Int
  blockNumber_in: [Int!]
  blockNumber_not_in: [Int!]
  timestamp: Int
  timestamp_not: Int
  timestamp_gt: Int
  timestamp_lt: Int
  timestamp_gte: Int
  timestamp_lte: Int
  timestamp_in: [Int!]
  timestamp_not_in: [Int!]
  user: String
  user_not: String
  user_gt: String
  user_lt: String
  user_gte: String
  user_lte: String
  user_in: [String!]
  user_not_in: [String!]
  user_contains: String
  user_contains_nocase: String
  user_not_contains: String
  user_not_contains_nocase: String
  user_starts_with: String
  user_starts_with_nocase: String
  user_not_starts_with: String
  user_not_starts_with_nocase: String
  user_ends_with: String
  user_ends_with_nocase: String
  user_not_ends_with: String
  user_not_ends_with_nocase: String
  user_: BILLING__User_filter
  amount: BigInt
  amount_not: BigInt
  amount_gt: BigInt
  amount_lt: BigInt
  amount_gte: BigInt
  amount_lte: BigInt
  amount_in: [BigInt!]
  amount_not_in: [BigInt!]
  type: BILLING__TransactionType
  type_not: BILLING__TransactionType
  type_in: [BILLING__TransactionType!]
  type_not_in: [BILLING__TransactionType!]
  """Filter for the block changed event."""
  _change_block: BILLING__BlockChangedFilter
}

enum BILLING__TokensAdded_orderBy {
  id
  hash
  blockNumber
  timestamp
  user
  amount
  type
}

"""
TokensPulled Transaction. Where the gateway pulls tokens from the user

"""
type BILLING__TokensPulled implements BILLING__Transaction {
  id: ID!
  hash: BILLING__Bytes!
  blockNumber: Int!
  timestamp: Int!
  user: BILLING__User!
  amount: BigInt!
  type: BILLING__TransactionType!
}

input BILLING__TokensPulled_filter {
  id: ID
  id_not: ID
  id_gt: ID
  id_lt: ID
  id_gte: ID
  id_lte: ID
  id_in: [ID!]
  id_not_in: [ID!]
  hash: BILLING__Bytes
  hash_not: BILLING__Bytes
  hash_gt: BILLING__Bytes
  hash_lt: BILLING__Bytes
  hash_gte: BILLING__Bytes
  hash_lte: BILLING__Bytes
  hash_in: [BILLING__Bytes!]
  hash_not_in: [BILLING__Bytes!]
  hash_contains: BILLING__Bytes
  hash_not_contains: BILLING__Bytes
  blockNumber: Int
  blockNumber_not: Int
  blockNumber_gt: Int
  blockNumber_lt: Int
  blockNumber_gte: Int
  blockNumber_lte: Int
  blockNumber_in: [Int!]
  blockNumber_not_in: [Int!]
  timestamp: Int
  timestamp_not: Int
  timestamp_gt: Int
  timestamp_lt: Int
  timestamp_gte: Int
  timestamp_lte: Int
  timestamp_in: [Int!]
  timestamp_not_in: [Int!]
  user: String
  user_not: String
  user_gt: String
  user_lt: String
  user_gte: String
  user_lte: String
  user_in: [String!]
  user_not_in: [String!]
  user_contains: String
  user_contains_nocase: String
  user_not_contains: String
  user_not_contains_nocase: String
  user_starts_with: String
  user_starts_with_nocase: String
  user_not_starts_with: String
  user_not_starts_with_nocase: String
  user_ends_with: String
  user_ends_with_nocase: String
  user_not_ends_with: String
  user_not_ends_with_nocase: String
  user_: BILLING__User_filter
  amount: BigInt
  amount_not: BigInt
  amount_gt: BigInt
  amount_lt: BigInt
  amount_gte: BigInt
  amount_lte: BigInt
  amount_in: [BigInt!]
  amount_not_in: [BigInt!]
  type: BILLING__TransactionType
  type_not: BILLING__TransactionType
  type_in: [BILLING__TransactionType!]
  type_not_in: [BILLING__TransactionType!]
  """Filter for the block changed event."""
  _change_block: BILLING__BlockChangedFilter
}

enum BILLING__TokensPulled_orderBy {
  id
  hash
  blockNumber
  timestamp
  user
  amount
  type
}

"""
TokensRemoved Transaction

"""
type BILLING__TokensRemoved implements BILLING__Transaction {
  id: ID!
  hash: BILLING__Bytes!
  blockNumber: Int!
  timestamp: Int!
  user: BILLING__User!
  amount: BigInt!
  type: BILLING__TransactionType!
  """User that the tokens are withdrawn to"""
  to: BILLING__Bytes!
}

input BILLING__TokensRemoved_filter {
  id: ID
  id_not: ID
  id_gt: ID
  id_lt: ID
  id_gte: ID
  id_lte: ID
  id_in: [ID!]
  id_not_in: [ID!]
  hash: BILLING__Bytes
  hash_not: BILLING__Bytes
  hash_gt: BILLING__Bytes
  hash_lt: BILLING__Bytes
  hash_gte: BILLING__Bytes
  hash_lte: BILLING__Bytes
  hash_in: [BILLING__Bytes!]
  hash_not_in: [BILLING__Bytes!]
  hash_contains: BILLING__Bytes
  hash_not_contains: BILLING__Bytes
  blockNumber: Int
  blockNumber_not: Int
  blockNumber_gt: Int
  blockNumber_lt: Int
  blockNumber_gte: Int
  blockNumber_lte: Int
  blockNumber_in: [Int!]
  blockNumber_not_in: [Int!]
  timestamp: Int
  timestamp_not: Int
  timestamp_gt: Int
  timestamp_lt: Int
  timestamp_gte: Int
  timestamp_lte: Int
  timestamp_in: [Int!]
  timestamp_not_in: [Int!]
  user: String
  user_not: String
  user_gt: String
  user_lt: String
  user_gte: String
  user_lte: String
  user_in: [String!]
  user_not_in: [String!]
  user_contains: String
  user_contains_nocase: String
  user_not_contains: String
  user_not_contains_nocase: String
  user_starts_with: String
  user_starts_with_nocase: String
  user_not_starts_with: String
  user_not_starts_with_nocase: String
  user_ends_with: String
  user_ends_with_nocase: String
  user_not_ends_with: String
  user_not_ends_with_nocase: String
  user_: BILLING__User_filter
  amount: BigInt
  amount_not: BigInt
  amount_gt: BigInt
  amount_lt: BigInt
  amount_gte: BigInt
  amount_lte: BigInt
  amount_in: [BigInt!]
  amount_not_in: [BigInt!]
  type: BILLING__TransactionType
  type_not: BILLING__TransactionType
  type_in: [BILLING__TransactionType!]
  type_not_in: [BILLING__TransactionType!]
  to: BILLING__Bytes
  to_not: BILLING__Bytes
  to_gt: BILLING__Bytes
  to_lt: BILLING__Bytes
  to_gte: BILLING__Bytes
  to_lte: BILLING__Bytes
  to_in: [BILLING__Bytes!]
  to_not_in: [BILLING__Bytes!]
  to_contains: BILLING__Bytes
  to_not_contains: BILLING__Bytes
  """Filter for the block changed event."""
  _change_block: BILLING__BlockChangedFilter
}

enum BILLING__TokensRemoved_orderBy {
  id
  hash
  blockNumber
  timestamp
  user
  amount
  type
  to
}

"""
A generic transaction

"""
interface BILLING__Transaction {
  """Transaction hash concatenated with event log index"""
  id: ID!
  """Transaction hash"""
  hash: BILLING__Bytes!
  """Block number for the transaction"""
  blockNumber: Int!
  """Timestamp for the transaction"""
  timestamp: Int!
  """User of the transaction"""
  user: BILLING__User!
  """Amount of tokens used in the transaction"""
  amount: BigInt!
  """Type of Graph Network transaction"""
  type: BILLING__TransactionType!
}

enum BILLING__TransactionType {
  TokensAdded
  TokensRemoved
  TokensPulled
}

input BILLING__Transaction_filter {
  id: ID
  id_not: ID
  id_gt: ID
  id_lt: ID
  id_gte: ID
  id_lte: ID
  id_in: [ID!]
  id_not_in: [ID!]
  hash: BILLING__Bytes
  hash_not: BILLING__Bytes
  hash_gt: BILLING__Bytes
  hash_lt: BILLING__Bytes
  hash_gte: BILLING__Bytes
  hash_lte: BILLING__Bytes
  hash_in: [BILLING__Bytes!]
  hash_not_in: [BILLING__Bytes!]
  hash_contains: BILLING__Bytes
  hash_not_contains: BILLING__Bytes
  blockNumber: Int
  blockNumber_not: Int
  blockNumber_gt: Int
  blockNumber_lt: Int
  blockNumber_gte: Int
  blockNumber_lte: Int
  blockNumber_in: [Int!]
  blockNumber_not_in: [Int!]
  timestamp: Int
  timestamp_not: Int
  timestamp_gt: Int
  timestamp_lt: Int
  timestamp_gte: Int
  timestamp_lte: Int
  timestamp_in: [Int!]
  timestamp_not_in: [Int!]
  user: String
  user_not: String
  user_gt: String
  user_lt: String
  user_gte: String
  user_lte: String
  user_in: [String!]
  user_not_in: [String!]
  user_contains: String
  user_contains_nocase: String
  user_not_contains: String
  user_not_contains_nocase: String
  user_starts_with: String
  user_starts_with_nocase: String
  user_not_starts_with: String
  user_not_starts_with_nocase: String
  user_ends_with: String
  user_ends_with_nocase: String
  user_not_ends_with: String
  user_not_ends_with_nocase: String
  user_: BILLING__User_filter
  amount: BigInt
  amount_not: BigInt
  amount_gt: BigInt
  amount_lt: BigInt
  amount_gte: BigInt
  amount_lte: BigInt
  amount_in: [BigInt!]
  amount_not_in: [BigInt!]
  type: BILLING__TransactionType
  type_not: BILLING__TransactionType
  type_in: [BILLING__TransactionType!]
  type_not_in: [BILLING__TransactionType!]
  """Filter for the block changed event."""
  _change_block: BILLING__BlockChangedFilter
}

enum BILLING__Transaction_orderBy {
  id
  hash
  blockNumber
  timestamp
  user
  amount
  type
}

"""
Curator Name Signal for a single Subgraph

"""
type BILLING__User {
  """Polygon address"""
  id: ID!
  """Balance of the user in the Billing contract"""
  billingBalance: BigInt!
  """[CUMULATIVE] Total amount of tokens added"""
  totalTokensAdded: BigInt!
  """[CUMULATIVE] Total amount of tokens pulled"""
  totalTokensPulled: BigInt!
  """[CUMULATIVE] Total amount of tokens removed/withdrawn"""
  totalTokensRemoved: BigInt!
  """All transactions of this user"""
  transactions(skip: Int = 0, first: Int = 100, orderBy: BILLING__Transaction_orderBy, orderDirection: BILLING__OrderDirection, where: BILLING__Transaction_filter): [BILLING__Transaction!]!
  """Current UserDailyData entity created"""
  currentDailyDataEntity: BILLING__UserDailyData
  """Previous UserDailyData entity created"""
  previousDailyDataEntity: BILLING__UserDailyData
  """[DEPRECATED] Total polygonGRT balance"""
  polygonGRTBalance: BigInt!
}

type BILLING__UserDailyData {
  """<SUBGRAPH ID>-<DAY NUMBER>"""
  id: ID!
  """Timestamp for the start of the day that this entity represents. UTC+0"""
  dayStart: BigInt!
  """Timestamp for the end of the day that this entity represents. UTC+0"""
  dayEnd: BigInt!
  """
  Number of the day this entity represents. Day 0 is the network launch day.
  """
  dayNumber: Int!
  """Original entity that the daily data entity tracks"""
  entity: BILLING__User!
  """[CUMULATIVE] Total amount of tokens added"""
  totalTokensAdded: BigInt!
  """[CUMULATIVE] Total amount of tokens pulled"""
  totalTokensPulled: BigInt!
  """[CUMULATIVE] Total amount of tokens removed/withdrawn"""
  totalTokensRemoved: BigInt!
  """[CURRENT] Amount of currently available balance"""
  billingBalance: BigInt!
  """[DELTA] Chage in total tokens added since the last DailyData point"""
  totalTokensAddedDelta: BigInt!
  """[DELTA] Chage in total tokens pulled since the last DailyData point"""
  totalTokensPulledDelta: BigInt!
  """
  [DELTA] Chage in total tokens removed/withdrawn since the last DailyData point
  """
  totalTokensRemovedDelta: BigInt!
  """
  [DELTA] Chage in total currently available balance since the last DailyData point
  """
  billingBalanceDelta: BigInt!
}

input BILLING__UserDailyData_filter {
  id: ID
  id_not: ID
  id_gt: ID
  id_lt: ID
  id_gte: ID
  id_lte: ID
  id_in: [ID!]
  id_not_in: [ID!]
  dayStart: BigInt
  dayStart_not: BigInt
  dayStart_gt: BigInt
  dayStart_lt: BigInt
  dayStart_gte: BigInt
  dayStart_lte: BigInt
  dayStart_in: [BigInt!]
  dayStart_not_in: [BigInt!]
  dayEnd: BigInt
  dayEnd_not: BigInt
  dayEnd_gt: BigInt
  dayEnd_lt: BigInt
  dayEnd_gte: BigInt
  dayEnd_lte: BigInt
  dayEnd_in: [BigInt!]
  dayEnd_not_in: [BigInt!]
  dayNumber: Int
  dayNumber_not: Int
  dayNumber_gt: Int
  dayNumber_lt: Int
  dayNumber_gte: Int
  dayNumber_lte: Int
  dayNumber_in: [Int!]
  dayNumber_not_in: [Int!]
  entity: String
  entity_not: String
  entity_gt: String
  entity_lt: String
  entity_gte: String
  entity_lte: String
  entity_in: [String!]
  entity_not_in: [String!]
  entity_contains: String
  entity_contains_nocase: String
  entity_not_contains: String
  entity_not_contains_nocase: String
  entity_starts_with: String
  entity_starts_with_nocase: String
  entity_not_starts_with: String
  entity_not_starts_with_nocase: String
  entity_ends_with: String
  entity_ends_with_nocase: String
  entity_not_ends_with: String
  entity_not_ends_with_nocase: String
  entity_: BILLING__User_filter
  totalTokensAdded: BigInt
  totalTokensAdded_not: BigInt
  totalTokensAdded_gt: BigInt
  totalTokensAdded_lt: BigInt
  totalTokensAdded_gte: BigInt
  totalTokensAdded_lte: BigInt
  totalTokensAdded_in: [BigInt!]
  totalTokensAdded_not_in: [BigInt!]
  totalTokensPulled: BigInt
  totalTokensPulled_not: BigInt
  totalTokensPulled_gt: BigInt
  totalTokensPulled_lt: BigInt
  totalTokensPulled_gte: BigInt
  totalTokensPulled_lte: BigInt
  totalTokensPulled_in: [BigInt!]
  totalTokensPulled_not_in: [BigInt!]
  totalTokensRemoved: BigInt
  totalTokensRemoved_not: BigInt
  totalTokensRemoved_gt: BigInt
  totalTokensRemoved_lt: BigInt
  totalTokensRemoved_gte: BigInt
  totalTokensRemoved_lte: BigInt
  totalTokensRemoved_in: [BigInt!]
  totalTokensRemoved_not_in: [BigInt!]
  billingBalance: BigInt
  billingBalance_not: BigInt
  billingBalance_gt: BigInt
  billingBalance_lt: BigInt
  billingBalance_gte: BigInt
  billingBalance_lte: BigInt
  billingBalance_in: [BigInt!]
  billingBalance_not_in: [BigInt!]
  totalTokensAddedDelta: BigInt
  totalTokensAddedDelta_not: BigInt
  totalTokensAddedDelta_gt: BigInt
  totalTokensAddedDelta_lt: BigInt
  totalTokensAddedDelta_gte: BigInt
  totalTokensAddedDelta_lte: BigInt
  totalTokensAddedDelta_in: [BigInt!]
  totalTokensAddedDelta_not_in: [BigInt!]
  totalTokensPulledDelta: BigInt
  totalTokensPulledDelta_not: BigInt
  totalTokensPulledDelta_gt: BigInt
  totalTokensPulledDelta_lt: BigInt
  totalTokensPulledDelta_gte: BigInt
  totalTokensPulledDelta_lte: BigInt
  totalTokensPulledDelta_in: [BigInt!]
  totalTokensPulledDelta_not_in: [BigInt!]
  totalTokensRemovedDelta: BigInt
  totalTokensRemovedDelta_not: BigInt
  totalTokensRemovedDelta_gt: BigInt
  totalTokensRemovedDelta_lt: BigInt
  totalTokensRemovedDelta_gte: BigInt
  totalTokensRemovedDelta_lte: BigInt
  totalTokensRemovedDelta_in: [BigInt!]
  totalTokensRemovedDelta_not_in: [BigInt!]
  billingBalanceDelta: BigInt
  billingBalanceDelta_not: BigInt
  billingBalanceDelta_gt: BigInt
  billingBalanceDelta_lt: BigInt
  billingBalanceDelta_gte: BigInt
  billingBalanceDelta_lte: BigInt
  billingBalanceDelta_in: [BigInt!]
  billingBalanceDelta_not_in: [BigInt!]
  """Filter for the block changed event."""
  _change_block: BILLING__BlockChangedFilter
}

enum BILLING__UserDailyData_orderBy {
  id
  dayStart
  dayEnd
  dayNumber
  entity
  totalTokensAdded
  totalTokensPulled
  totalTokensRemoved
  billingBalance
  totalTokensAddedDelta
  totalTokensPulledDelta
  totalTokensRemovedDelta
  billingBalanceDelta
}

input BILLING__User_filter {
  id: ID
  id_not: ID
  id_gt: ID
  id_lt: ID
  id_gte: ID
  id_lte: ID
  id_in: [ID!]
  id_not_in: [ID!]
  billingBalance: BigInt
  billingBalance_not: BigInt
  billingBalance_gt: BigInt
  billingBalance_lt: BigInt
  billingBalance_gte: BigInt
  billingBalance_lte: BigInt
  billingBalance_in: [BigInt!]
  billingBalance_not_in: [BigInt!]
  totalTokensAdded: BigInt
  totalTokensAdded_not: BigInt
  totalTokensAdded_gt: BigInt
  totalTokensAdded_lt: BigInt
  totalTokensAdded_gte: BigInt
  totalTokensAdded_lte: BigInt
  totalTokensAdded_in: [BigInt!]
  totalTokensAdded_not_in: [BigInt!]
  totalTokensPulled: BigInt
  totalTokensPulled_not: BigInt
  totalTokensPulled_gt: BigInt
  totalTokensPulled_lt: BigInt
  totalTokensPulled_gte: BigInt
  totalTokensPulled_lte: BigInt
  totalTokensPulled_in: [BigInt!]
  totalTokensPulled_not_in: [BigInt!]
  totalTokensRemoved: BigInt
  totalTokensRemoved_not: BigInt
  totalTokensRemoved_gt: BigInt
  totalTokensRemoved_lt: BigInt
  totalTokensRemoved_gte: BigInt
  totalTokensRemoved_lte: BigInt
  totalTokensRemoved_in: [BigInt!]
  totalTokensRemoved_not_in: [BigInt!]
  transactions_: BILLING__Transaction_filter
  currentDailyDataEntity: String
  currentDailyDataEntity_not: String
  currentDailyDataEntity_gt: String
  currentDailyDataEntity_lt: String
  currentDailyDataEntity_gte: String
  currentDailyDataEntity_lte: String
  currentDailyDataEntity_in: [String!]
  currentDailyDataEntity_not_in: [String!]
  currentDailyDataEntity_contains: String
  currentDailyDataEntity_contains_nocase: String
  currentDailyDataEntity_not_contains: String
  currentDailyDataEntity_not_contains_nocase: String
  currentDailyDataEntity_starts_with: String
  currentDailyDataEntity_starts_with_nocase: String
  currentDailyDataEntity_not_starts_with: String
  currentDailyDataEntity_not_starts_with_nocase: String
  currentDailyDataEntity_ends_with: String
  currentDailyDataEntity_ends_with_nocase: String
  currentDailyDataEntity_not_ends_with: String
  currentDailyDataEntity_not_ends_with_nocase: String
  currentDailyDataEntity_: BILLING__UserDailyData_filter
  previousDailyDataEntity: String
  previousDailyDataEntity_not: String
  previousDailyDataEntity_gt: String
  previousDailyDataEntity_lt: String
  previousDailyDataEntity_gte: String
  previousDailyDataEntity_lte: String
  previousDailyDataEntity_in: [String!]
  previousDailyDataEntity_not_in: [String!]
  previousDailyDataEntity_contains: String
  previousDailyDataEntity_contains_nocase: String
  previousDailyDataEntity_not_contains: String
  previousDailyDataEntity_not_contains_nocase: String
  previousDailyDataEntity_starts_with: String
  previousDailyDataEntity_starts_with_nocase: String
  previousDailyDataEntity_not_starts_with: String
  previousDailyDataEntity_not_starts_with_nocase: String
  previousDailyDataEntity_ends_with: String
  previousDailyDataEntity_ends_with_nocase: String
  previousDailyDataEntity_not_ends_with: String
  previousDailyDataEntity_not_ends_with_nocase: String
  previousDailyDataEntity_: BILLING__UserDailyData_filter
  polygonGRTBalance: BigInt
  polygonGRTBalance_not: BigInt
  polygonGRTBalance_gt: BigInt
  polygonGRTBalance_lt: BigInt
  polygonGRTBalance_gte: BigInt
  polygonGRTBalance_lte: BigInt
  polygonGRTBalance_in: [BigInt!]
  polygonGRTBalance_not_in: [BigInt!]
  """Filter for the block changed event."""
  _change_block: BILLING__BlockChangedFilter
}

enum BILLING__User_orderBy {
  id
  billingBalance
  totalTokensAdded
  totalTokensPulled
  totalTokensRemoved
  transactions
  currentDailyDataEntity
  previousDailyDataEntity
  polygonGRTBalance
}

type BILLING___Block_ {
  """The hash of the block"""
  hash: BILLING__Bytes
  """The block number"""
  number: Int!
  """Integer representation of the timestamp stored in blocks for the chain"""
  timestamp: Int
}

"""The type for the top-level _meta field"""
type BILLING___Meta_ {
  """
  Information about a specific subgraph block. The hash of the block
  will be null if the _meta field has a block constraint that asks for
  a block number. It will be filled if the _meta field has no block constraint
  and therefore asks for the latest  block
  
  """
  block: BILLING___Block_!
  """The deployment ID"""
  deployment: String!
  """If `true`, the subgraph encountered indexing errors at some past block"""
  hasIndexingErrors: Boolean!
}

enum BILLING___SubgraphErrorPolicy_ {
  """Data will be returned even if the subgraph has indexing errors"""
  allow
  """
  If the subgraph has indexing errors, data will be omitted. The default.
  """
  deny
}